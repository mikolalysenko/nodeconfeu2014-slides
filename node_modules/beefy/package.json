{
  "name": "beefy",
  "version": "2.1.0",
  "description": "local development server that aims to make using browserify fast and fun",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/beefy.git"
  },
  "scripts": {
    "test": "node test",
    "test-cov": "istanbul cover test/index.js"
  },
  "keywords": [
    "simplehttpserver",
    "browserify"
  ],
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "license": "MIT",
  "dependencies": {
    "ansicolors": "~0.3.2",
    "chokidar": "^0.8.2",
    "concat-stream": "^1.4.3",
    "find-global-packages": "0.0.1",
    "ignorepatterns": "^1.0.1",
    "leftpad": "0.0.0",
    "mime": "~1.2.9",
    "minimist": "0.0.8",
    "open": "0.0.3",
    "portfinder": "~0.2.1",
    "pretty-bytes": "~0.1.0",
    "resolve": "^0.6.1",
    "response-stream": "0.0.0",
    "script-injector": "~0.1.0",
    "through": "~2.2.0",
    "which": "~1.0.5",
    "xtend": "~2.1.2"
  },
  "bin": {
    "beefy": "./bin/beefy"
  },
  "devDependencies": {
    "tape": "~2.10.2",
    "watchify": "^0.10.2",
    "browserify": "^3.32.1",
    "covert": "^0.3.1",
    "touch": "0.0.3",
    "mock": "^0.1.1",
    "dotpathlookup": "0.0.1",
    "jsl": "^0.1.3",
    "istanbul": "^0.2.8"
  },
  "readme": "# beefy\n\na local development server designed to work with browserify.\n\nit:\n\n* can live reload your browser when your code changes (if you want)\n* works with whatever version of browserify or watchify; globally installed or \n  locally installed to `node_modules/`.\n* will spit compile errors out into the browser so you don't have that\n  1-2 seconds of cognitive dissonance and profound ennui that follows\n  refreshing the page only to get a blank screen.\n* will spit out a default `index.html` for missing routes so you don't\n  need to even muck about with HTML to get started\n* serves up static files with grace and aplomb (and also appropriate\n  mimetypes)\n* is designed to fall away gracefully, as your project gets bigger.\n* love you, unconditionally\n\n## how do I get it?\n\n`npm install -g beefy`; and if you want to always have a browserify available\nfor beefy to use, `npm install -g browserify`.\n\n## usage\n\n```javascript\n$ cd directory/you/want/served\n$ beefy path/to/thing/you/want/browserified.js [PORT] [-- browserify args]\n```\n\n## what bundler does it use?\n\nBeefy searches for bundlers in the following order:\n\n* First, it checks your local project's node_modules for watchify.\n* Then it checks locally for browserify.\n* Failing that, it checks for a global watchify.\n* Then falls back to a global browserify.\n\n#### `path/to/file.js`\n\nthe path to the file you want browserified. can be just a normal node module.\nyou can also alias it: `path/to/file.js:bundle.js` if you want -- so all requests\nto `bundle.js` will browserify `path/to/file.js`. this is helpful for when you're\nwriting `gh-pages`-style sites that already have an index.html, and expect the\nbundle to be pregenerated and available at a certain path.\n\nYou may provide multiple entry points, if you desire!\n\n#### `--browserify command`\n#### `--bundler command`\n\nuse `command` instead of `browserify` or `./node_modules/.bin/browserify`.\n\n~~in theory, you could even get this working with `r.js`, but that would probably\nbe scary and bats would fly out of it. but it's there if you need it!~~ if you want\nto use `r.js` with beefy, you'll need a config that can write the resulting bundle\nto stdout, and you can run beefy with `beefy :output-url.js --bundler r.js -- -o config.js`.\n\n**NB:** This will not work in Windows.\n\n#### `--live`\n\nEnable live reloading. this'll start up a sideband server and an `fs` watch on\nthe current working directory -- if you save a file, your browser will refresh.\n\nif you're not using the generated index file, beefy has your back -- it'll still\nautomatically inject the appropriate script tag.\n\n```html\n    <script src=\"/-/live-reload.js\"></script>\n```\n\n#### `--cwd dir`\n\nserve files as if running from `dir`.\n\n#### `--debug=false`\n\nturn off browserify source map output. by default, beefy automatically inserts\n`-d` into the browserify args -- this turns that behavior off.\n\n#### `--open`\n\nautomatically discover a port and open it using your default browser.\n\n#### `--index=path/to/file`\n\nProvide your own default index! This works great for single page apps,\nas every URL on your site will be redirected to the same HTML file. Every\ninstance of `{{entry}}` will be replaced with the entry point of your app.\n\n## api\n\n```javascript\nvar beefy = require('beefy')\n  , http = require('http')\n\nvar handler = beefy('entry.js')\n\nhttp.createServer(handler).listen(8124)\n```\n\nBeefy defaults the `cwd` to the directory of the file requiring it,\nso it's easy to switch from CLI mode to building a server.\n\nAs your server grows, you may want to expand on the information you're\ngiving beefy:\n\n```javascript\nvar beefy = require('beefy')\n  , http = require('http')\n\nhttp.createServer(beefy({\n    entries: ['entry.js']\n  , cwd: __dirname\n  , live: true\n  , quiet: false\n  , bundlerFlags: ['-t', 'brfs']\n  , unhandled: on404\n)).listen(8124)\n\nfunction on404(req, resp) {\n  resp.writeHead(404, {})\n  resp.end('sorry folks!')\n}\n```\n\n### beefy(opts: BeefyOptions, ready: (err: Error) => void)\n\nCreate a request handler suitable for providing to `http.createServer`.\nCalls `ready` once the appropriate bundler has been located. If `ready`\nis not provided and a bundler isn't located, an error is thrown.\n\n### BeefyOptions\n\nBeefy's options are a simple object, which may contain the following\nattributes:\n\n* `cwd`: String. The base directory that beefy is serving. Defaults to the\ndirectory of the module that **first** required beefy.\n* `quiet`: Boolean. Whether or not to output request information to the console. Defaults to false.\n* `live`: Boolean. Whether to enable live reloading. Defaults to false.\n* `bundler`: null, String, or Function. If a string is given, beefy will\nattempt to run that string as a child process whenever the path is given.\nIf a function is given, it is expected to accept a path and return an \nobject comprised of `{stdout: ReadableStream, stderr: ReadableStream}`. If\nnot given, beefy will search for an appropriate bundler.\n* `bundlerFlags`: Flags to be passed to the bundler. Ignored if `bundler`\nis a function.\n* `entries`: String, Array, or Object. The canonical form is that of an\nobject mapping URL pathnames to paths on disk relative to `cwd`. If given\nas an array or string, entries will be mapped like so: `index.js` will\nmap `/index.js` to `<cwd>/index.js`.\n* `unhandled`: Function accepting req and resp. Called for 404s. If not\ngiven, a default 404 handler will be used.\n* `watchify`: defaults to true -- when true, beefy will prefer using watchify\nto browserify. If false, beefy will prefer browserify.\n\nBeefy may accept, as a shorthand, `beefy(\"file.js\")` or `beefy([\"file.js\"])`.\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chrisdickinson/beefy/issues"
  },
  "homepage": "https://github.com/chrisdickinson/beefy",
  "_id": "beefy@2.1.0",
  "_from": "beefy@"
}
